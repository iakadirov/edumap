# Анализ данных областей и регионов в БД

## Текущее состояние БД

### Поля в таблице `organizations`:

1. **`region`** (TEXT) - добавлено в миграции `010_add_priority_fields_phase2.sql`
   - Область (Ташкент, Андижан, Самарканд, и т.д.)
   - Индекс: `idx_organizations_region`

2. **`district`** (TEXT) - было с самого начала (`001_create_tables.sql`)
   - Район (Яшнабадский, Юнусабадский, и т.д.)
   - Индекс: `idx_organizations_district`

3. **`city`** (TEXT) - было с самого начала
   - Город
   - Индекс: `idx_organizations_city`

---

## Проблемы текущей структуры

### 1. Нет нормализации данных

- Значения хранятся как **текст** (например: "Андижанская область", "Яшнабадский район")
- Нет связи между `region` и `district`
- Нет справочных таблиц для областей и районов
- Сложно сопоставить данные из репозитория uzbekistan-regions-data

### 2. Форматы данных могут различаться

В тестовых данных используются:
- Русские названия: "Ташкент", "Яшнабадский"
- Возможны варианты: "Андижанская область" vs "Андижан"

### 3. Нет связи region ↔ district

В репозитории uzbekistan-regions-data:
- Районы имеют `region_id` для связи с областями
- В БД такой связи нет - это просто текстовые поля

---

## Решения

### Вариант 1: Справочные таблицы (рекомендуется)

Создать нормализованные таблицы:

```sql
-- Таблица областей
CREATE TABLE regions (
  id INTEGER PRIMARY KEY,
  soato_id INTEGER UNIQUE,
  name_uz TEXT NOT NULL,
  name_oz TEXT,
  name_ru TEXT NOT NULL
);

-- Таблица районов
CREATE TABLE districts (
  id INTEGER PRIMARY KEY,
  region_id INTEGER REFERENCES regions(id),
  soato_id INTEGER UNIQUE,
  name_uz TEXT NOT NULL,
  name_oz TEXT,
  name_ru TEXT NOT NULL
);

-- Обновить organizations
ALTER TABLE organizations
  ADD COLUMN region_id INTEGER REFERENCES regions(id),
  ADD COLUMN district_id INTEGER REFERENCES districts(id);
```

**Преимущества:**
- Нормализованная структура
- Легко сопоставлять с данными из репозитория
- Гарантированная целостность данных
- Можно добавить дополнительные поля (координаты, и т.д.)

**Недостатки:**
- Нужна миграция существующих данных
- Более сложные запросы (JOIN)

### Вариант 2: Использовать текстовые поля + маппинг

Оставить текущую структуру, но добавить маппинг на фронтенде:

```typescript
// Маппинг названий областей из репозитория к значениям в БД
const regionMapping: Record<string, string> = {
  'Toshkent shahri': 'Ташкент',
  'Toshkent viloyati': 'Ташкентская область',
  'Andijon viloyati': 'Андижанская область',
  // ...
};
```

**Преимущества:**
- Минимальные изменения
- Быстрая реализация

**Недостатки:**
- Хрупкость (зависит от точного совпадения названий)
- Нет гарантии целостности данных
- Сложнее поддерживать

### Вариант 3: Гибридный подход

1. Создать справочные таблицы
2. Оставить текстовые поля для обратной совместимости
3. Постепенно мигрировать данные

---

## Рекомендация

**Использовать Вариант 1 (Справочные таблицы)** по следующим причинам:

1. ✅ Долгосрочная масштабируемость
2. ✅ Интеграция с данными из репозитория uzbekistan-regions-data
3. ✅ Целостность данных
4. ✅ Возможность расширения (координаты, статистика, и т.д.)

### План миграции:

1. Создать таблицы `regions` и `districts`
2. Загрузить данные из репозитория
3. Создать маппинг существующих текстовых значений к ID
4. Добавить `region_id` и `district_id` в `organizations`
5. Мигрировать существующие данные
6. Оставить текстовые поля для обратной совместимости (опционально)

---

## Данные из репозитория

### Структура `regions.json`:
```json
{
  "id": 11,
  "soato_id": 1726,
  "name_uz": "Toshkent shahri",
  "name_oz": "Тошкент шаҳри",
  "name_ru": "город Ташкент"
}
```

### Структура `districts.json`:
```json
{
  "id": 16,
  "region_id": 2,
  "soato_id": 1703202,
  "name_uz": "Oltinko'l tumani",
  "name_oz": "Олтинкўл тумани",
  "name_ru": "Алтынкульский район"
}
```

### Связь:
- `districts.region_id` → `regions.id`
- Можно фильтровать районы по выбранной области

---

## Вопросы для уточнения

1. Какие данные сейчас в БД в полях `region`, `district`, `city`?
2. Используется ли поле `region` в текущих записях?
3. Нужна ли обратная совместимость с текстовыми полями?

